<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>Neon Flight: Overdrive</title>
    <style>
        :root {
            --neon-blue: #0ff;
            --neon-pink: #f0f;
            --neon-yellow: #ff0;
            --neon-red: #f00;
            --bg-color: #0d0d2b;
        }
        body {
            margin: 0;
            overflow: hidden;
            background: var(--bg-color);
            font-family: 'Courier New', Courier, monospace;
            color: #fff;
            user-select: none;
        }
        canvas { display: block; }

        /* UI Elements */
        #ui, #shopScreen, #gameOverScreen {
            position: absolute;
            padding: 20px;
            z-index: 10;
        }
        #ui {
            top: 10px; left: 10px;
            pointer-events: none;
        }
        h1 { margin: 0 0 10px 0; text-shadow: 0 0 10px var(--neon-blue); }
        h2 { text-shadow: 0 0 10px var(--neon-pink); }
        p { font-size: 18px; margin: 5px 0; }
        .stat-box { background: rgba(0,0,0,0.5); padding: 10px; border-radius: 5px; border: 1px solid var(--neon-blue); display: inline-block; margin-right: 10px;}

        /* Screens (Game Over & Shop) */
        #gameOverScreen, #shopScreen {
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            border: 3px solid var(--neon-pink);
            box-shadow: 0 0 30px var(--neon-pink);
            border-radius: 15px;
            min-width: 400px;
            display: none; /* –°–∫—Ä—ã—Ç—ã –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
        }

        /* Buttons & Shop Items */
        button {
            background: var(--neon-pink);
            color: #fff;
            border: none; padding: 12px 24px;
            font-size: 20px; cursor: pointer;
            font-family: inherit; font-weight: bold;
            margin: 10px;
            box-shadow: 0 0 15px var(--neon-pink);
            transition: 0.3s; clip-path: polygon(10% 0, 100% 0, 90% 100%, 0% 100%);
        }
        button:hover:not(:disabled) { background: #fff; color: var(--neon-pink); transform: scale(1.05); }
        button:disabled { opacity: 0.5; cursor: not-allowed; filter: grayscale(1);}
        button.play-btn { background: var(--neon-blue); box-shadow: 0 0 15px var(--neon-blue); color: #000; clip-path: none; border-radius: 5px;}
        button.play-btn:hover { background: #fff; color: var(--neon-blue);}

        .shop-item {
            display: flex; justify-content: space-between; align-items: center;
            background: rgba(255,255,255,0.1); margin: 10px 0; padding: 10px 20px;
            border-radius: 5px; border-left: 4px solid var(--neon-yellow);
        }
        .shop-info { text-align: left; }
        .shop-info h3 { margin: 0; color: var(--neon-yellow); }
        .shop-info small { opacity: 0.7; }
    </style>
</head>
<body>

<div id="ui">
    <h1>NEON OVERDRIVE</h1>
    <div class="stat-box">–°—á–µ—Ç: <span id="scoreVal">0</span></div>
    <div class="stat-box" style="border-color: var(--neon-yellow); color: var(--neon-yellow);">–ú–æ–Ω–µ—Ç—ã: <span id="coinsRunVal">0</span></div>
    <div id="shieldIndicator" class="stat-box" style="display:none; border-color: var(--neon-blue); color: var(--neon-blue);">üõ°Ô∏è –©–ò–¢ –ê–ö–¢–ò–í–ï–ù</div>
</div>

<div id="gameOverScreen">
    <h1 style="color: var(--neon-red); text-shadow: 0 0 20px var(--neon-red);">–°–ò–°–¢–ï–ú–ê –ü–û–í–†–ï–ñ–î–ï–ù–ê</h1>
    <p>–°—á–µ—Ç –∑–∞ –∑–∞–±–µ–≥: <span id="finalScore">0</span></p>
    <p style="color: var(--neon-yellow);">–°–æ–±—Ä–∞–Ω–æ –º–æ–Ω–µ—Ç: +<span id="finalCoins">0</span></p>
    <br>
    <button class="play-btn" onclick="openShop()">–í –ú–ê–ì–ê–ó–ò–ù / –†–ï–°–¢–ê–†–¢</button>
</div>

<div id="shopScreen">
    <h2>–ú–ê–ì–ê–ó–ò–ù –£–õ–£–ß–®–ï–ù–ò–ô</h2>
    <p>–í—Å–µ–≥–æ –º–æ–Ω–µ—Ç: <span id="totalCoinsVal" style="color: var(--neon-yellow); font-weight: bold;">0</span></p>
    <hr style="border-color: var(--neon-pink); opacity: 0.3;">

    <div class="shop-item">
        <div class="shop-info">
            <h3>–ú–∞–≥–Ω–∏—Ç (–£—Ä. <span id="magnetLvl">1</span>)</h3>
            <small>–ü—Ä–∏—Ç—è–≥–∏–≤–∞–µ—Ç –º–æ–Ω–µ—Ç—ã. –¶–µ–Ω–∞: <span id="magnetCost">50</span></small>
        </div>
        <button id="buyMagnetBtn" onclick="buyUpgrade('magnet')">–ö–£–ü–ò–¢–¨</button>
    </div>

    <div class="shop-item">
        <div class="shop-info">
            <h3>–ú–Ω–æ–∂–∏—Ç–µ–ª—å –æ—á–∫–æ–≤ (–£—Ä. <span id="multiplierLvl">1</span>)</h3>
            <small>–ë–æ–ª—å—à–µ –æ—á–∫–æ–≤ –∑–∞ –º–æ–Ω–µ—Ç—ã. –¶–µ–Ω–∞: <span id="multiplierCost">100</span></small>
        </div>
        <button id="buyMultiplierBtn" onclick="buyUpgrade('multiplier')">–ö–£–ü–ò–¢–¨</button>
    </div>

    <div class="shop-item">
        <div class="shop-info">
            <h3>–≠–Ω–µ—Ä–≥–æ—â–∏—Ç (–û–¥–Ω–æ—Ä–∞–∑–æ–≤—ã–π)</h3>
            <small>–°–ø–∞—Å–∞–µ—Ç –æ—Ç 1 —É–¥–∞—Ä–∞. –¶–µ–Ω–∞: 150</small>
        </div>
        <button id="buyShieldBtn" onclick="buyShield()">–ö–£–ü–ò–¢–¨</button>
    </div>

    <hr style="border-color: var(--neon-pink); opacity: 0.3;">
    <button class="play-btn" style="width: 80%; font-size: 24px;" onclick="startGame()">–í –ü–û–õ–ï–¢!</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    // --- –ì–õ–û–ë–ê–õ–¨–ù–û–ï –°–û–°–¢–û–Ø–ù–ò–ï –ò –°–û–•–†–ê–ù–ï–ù–ò–ï ---
    let gameState = {
        totalCoins: 0,
        upgrades: {
            magnetLvl: 1,
            multiplierLvl: 1,
            hasShield: false
        }
    };

    // –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö
    const savedData = localStorage.getItem('neonFlightSave');
    if (savedData) {
        gameState = JSON.parse(savedData);
    }

    function saveData() {
        localStorage.setItem('neonFlightSave', JSON.stringify(gameState));
        updateShopUI();
    }

    // –¶–µ–Ω—ã —É–ª—É—á—à–µ–Ω–∏–π (—Ñ–æ—Ä–º—É–ª–∞: –±–∞–∑–æ–≤–∞—è —Ü–µ–Ω–∞ * —É—Ä–æ–≤–µ–Ω—å)
    const getCost = (type) => type === 'magnet' ? 50 * gameState.upgrades.magnetLvl : 100 * gameState.upgrades.multiplierLvl;
    const shieldCost = 150;

    // --- –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–≥—Ä–æ–≤–æ–π —Å–µ—Å—Å–∏–∏
    let frames = 0;
    let score = 0;
    let coinsCollectedInRun = 0;
    let gameSpeed = 3;
    let isGameOver = false;
    let isGameRunning = false;
    let animationId;

    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
    let isFlying = false;
    ['mousedown', 'touchstart'].forEach(evt =>
        document.addEventListener(evt, (e) => {
            if(isGameRunning && !isGameOver) { e.preventDefault(); isFlying = true; }
        }, {passive: false})
    );
    ['mouseup', 'touchend'].forEach(evt =>
        document.addEventListener(evt, (e) => {
            if(isGameRunning && !isGameOver) { e.preventDefault(); isFlying = false; }
        })
    );
    document.addEventListener('keydown', (e) => { if (e.code === 'Space') isFlying = true; });
    document.addEventListener('keyup', (e) => { if (e.code === 'Space') isFlying = false; });

    // –ò–≥—Ä–æ–∫ (–§–∏–∑–∏–∫–∞ –æ—Å—Ç–∞–ª–∞—Å—å –ø—Ä–µ–∂–Ω–µ–π)
    const player = {
        x: 100, y: canvas.height / 2,
        radius: 15, color: '#0ff',
        dy: 0, gravity: 0.15, lift: -0.4, maxSpeed: 6,
        draw() {
            // –†–∏—Å—É–µ–º —â–∏—Ç, –µ—Å–ª–∏ –µ—Å—Ç—å
            if(gameState.upgrades.hasShield) {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius + 5, 0, Math.PI * 2);
                ctx.strokeStyle = '#0ff'; ctx.lineWidth = 2;
                ctx.shadowBlur = 10; ctx.shadowColor = '#0ff';
                ctx.stroke(); ctx.shadowBlur = 0;
            }
            // –†–∏—Å—É–µ–º —à–∞—Ä
            ctx.shadowBlur = 20; ctx.shadowColor = this.color;
            ctx.fillStyle = this.color;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2); ctx.fill();
            ctx.shadowBlur = 0;
            ctx.fillStyle = 'white';
            ctx.beginPath(); ctx.arc(this.x - 5, this.y - 5, 4, 0, Math.PI * 2); ctx.fill();
        },
        update() {
            if (isFlying) this.dy += this.lift;
            this.dy += this.gravity;
            this.y += this.dy;
            // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏
            if (this.dy > this.maxSpeed) this.dy = this.maxSpeed;
            if (this.dy < -this.maxSpeed) this.dy = -this.maxSpeed;
            // –ì—Ä–∞–Ω–∏—Ü—ã
            if (this.y + this.radius > canvas.height) hitObstacle();
            if (this.y - this.radius < 0) { this.y = this.radius; this.dy = 0; }
        }
    };

    // –ò–≥—Ä–æ–≤—ã–µ –æ–±—ä–µ–∫—Ç—ã
    let particles = [], obstacles = [], coins = [], enemies = [];

    class Particle {
        constructor(x, y, color, speedMult = 1) {
            this.x = x; this.y = y;
            this.size = Math.random() * 5 + 2;
            this.color = color;
            this.speedX = (Math.random() - 0.5) * speedMult;
            this.speedY = (Math.random() - 0.5) * speedMult;
            this.life = 100;
        }
        update() {
            this.x -= gameSpeed * 0.5 + this.speedX;
            this.y += this.speedY;
            this.life -= 2; this.size *= 0.96;
        }
        draw() {
            ctx.fillStyle = this.color;
            ctx.globalAlpha = this.life / 100;
            ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // –í–†–ê–ì–ò (–î—Ä–æ–Ω—ã)
    class Enemy {
        constructor() {
            this.x = canvas.width + 50;
            this.y = Math.random() * canvas.height;
            this.baseY = this.y;
            this.radius = 12;
            this.angle = Math.random() * Math.PI;
            this.speed = gameSpeed * 1.5 + Math.random(); // –ë—ã—Å—Ç—Ä–µ–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è
        }
        update() {
            this.x -= this.speed;
            this.angle += 0.05;
            this.y = this.baseY + Math.sin(this.angle) * 80; // –ü–æ–ª–µ—Ç –≤–æ–ª–Ω–æ–π

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è
            let dist = Math.hypot(player.x - this.x, player.y - this.y);
            if (dist < player.radius + this.radius - 2) {
                hitObstacle();
                return true; // Hit occurred
            }
            return false;
        }
        draw() {
            ctx.shadowBlur = 15; ctx.shadowColor = '#f00';
            ctx.fillStyle = '#f00';
            ctx.beginPath();
            // –†–∏—Å—É–µ–º —à–∏–ø–∞—Å—Ç—É—é —Ñ–æ—Ä–º—É
            for(let i = 0; i < 6; i++) {
                let a = this.angle * 2 + i * (Math.PI/3);
                let r = this.radius * (i % 2 === 0 ? 1.5 : 0.8);
                ctx.lineTo(this.x + Math.cos(a) * r, this.y + Math.sin(a) * r);
            }
            ctx.fill(); ctx.shadowBlur = 0;
        }
    }

    // –ü–†–ï–ü–Ø–¢–°–¢–í–ò–Ø (–†–∞–∑–Ω—ã–µ —Ç–∏–ø—ã)
    class Obstacle {
        constructor(x, y, w, h, type) {
            this.x = x; this.y = y; this.w = w; this.h = h;
            this.type = type || 'static'; // 'static', 'moving', 'blade'
            this.color = '#f0f';
            this.moveSpeedY = Math.random() > 0.5 ? 2 : -2;
            this.angle = 0;
        }
        update() {
            this.x -= gameSpeed;
            if (this.type === 'moving') {
                this.y += this.moveSpeedY;
                if (this.y < -50 || this.y + this.h > canvas.height + 50) this.moveSpeedY *= -1;
            } else if (this.type === 'blade') {
                this.angle += 0.1;
            }
        }
        draw() {
            ctx.shadowBlur = 15; ctx.shadowColor = this.color;
            ctx.fillStyle = this.color;
            if (this.type !== 'blade') {
                ctx.fillRect(this.x, this.y, this.w, this.h);
            } else {
                // –í—Ä–∞—â–∞—é—â–µ–µ—Å—è –ª–µ–∑–≤–∏–µ
                ctx.save();
                ctx.translate(this.x + this.w/2, this.y + this.h/2);
                ctx.rotate(this.angle);
                ctx.fillRect(-this.w/2, -this.h/2, this.w, this.h);
                ctx.fillRect(-this.h/2, -this.w/2, this.h, this.w); // –ö—Ä–µ—Å—Ç–æ–≤–∏–Ω–∞
                ctx.restore();
            }
            ctx.shadowBlur = 0;
        }
        checkCollision(p) {
            let margin = 5;
            // –ü—Ä–æ—Å—Ç–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫–∞ –¥–ª—è –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ (–¥–ª—è –ª–µ–∑–≤–∏—è –Ω–µ —Å–æ–≤—Å–µ–º —Ç–æ—á–Ω–æ, –Ω–æ –∏–≥—Ä–∞–±–µ–ª—å–Ω–æ)
            return (
                p.x + p.radius - margin > this.x && p.x - p.radius + margin < this.x + this.w &&
                p.y + p.radius - margin > this.y && p.y - p.radius + margin < this.y + this.h
            );
        }
    }

    // --- –°–ü–ê–í–ù–ï–†–´ ---
    function spawnGameObjects() {
        // –ü—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
        if (frames % 180 === 0) {
            let gap = 300;
            let minH = 50;
            let randomH = Math.random() * (canvas.height - gap - minH * 2) + minH;
            // –®–∞–Ω—Å –Ω–∞ –ø–æ—è–≤–ª–µ–Ω–∏–µ –æ—Å–æ–±–æ–≥–æ –ø—Ä–µ–ø—è—Ç—Å—Ç–≤–∏—è
            let type = Math.random() > 0.7 ? 'moving' : 'static';

            obstacles.push(new Obstacle(canvas.width, 0, 50, randomH, type));
            obstacles.push(new Obstacle(canvas.width, randomH + gap, 50, canvas.height - (randomH + gap), type));

            // –õ–µ–∑–≤–∏–µ –ø–æ—Å–µ—Ä–µ–¥–∏–Ω–µ –∏–Ω–æ–≥–¥–∞
            if (Math.random() > 0.8 && frames > 500) {
                obstacles.push(new Obstacle(canvas.width + 25, randomH + gap/2 - 10, 100, 20, 'blade'));
            }

            // –ú–æ–Ω–µ—Ç–∫–∞ –≤ –ø—Ä–æ—Ö–æ–¥–µ
            coins.push({
                x: canvas.width + 25, y: randomH + gap / 2,
                radius: 12, collected: false, vy: 0, vx: 0
            });
        }
        // –í—Ä–∞–≥–∏ (–ø–æ—è–≤–ª—è—é—Ç—Å—è –ø–æ–∑–∂–µ)
        if (frames > 600 && frames % 250 === 0) {
            enemies.push(new Enemy());
        }
    }

    // --- –û–ë–†–ê–ë–û–¢–ö–ê –°–¢–û–õ–ö–ù–û–í–ï–ù–ò–Ø ---
    function hitObstacle() {
        if (gameState.upgrades.hasShield) {
            // –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —â–∏—Ç
            gameState.upgrades.hasShield = false;
            document.getElementById('shieldIndicator').style.display = 'none';
            // –≠—Ñ—Ñ–µ–∫—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —â–∏—Ç–∞ (–≤–∑—Ä—ã–≤ –∏ –æ—á–∏—Å—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞)
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            obstacles = []; enemies = []; // –£–Ω–∏—á—Ç–æ–∂–∏—Ç—å –≤—Å–µ —É–≥—Ä–æ–∑—ã
            for(let i=0; i<30; i++) particles.push(new Particle(player.x, player.y, '#0ff', 10));
        } else {
            gameOver();
        }
    }

    // --- –ò–ì–†–û–í–û–ô –¶–ò–ö–õ ---
    function animate() {
        if (!isGameRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        frames++;
        if (frames % 1000 === 0) gameSpeed += 0.3; // –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–µ —É—Å–∫–æ—Ä–µ–Ω–∏–µ

        handleBackground();
        spawnGameObjects();

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—ä–µ–∫—Ç–æ–≤
        if (frames % 5 === 0) particles.push(new Particle(player.x - 10, player.y, '#0ff'));
        particles.forEach((p, i) => { p.update(); p.draw(); if (p.life <= 0) particles.splice(i, 1); });

        obstacles.forEach((obs, i) => {
            obs.update(); obs.draw();
            if (obs.checkCollision(player)) hitObstacle();
            if (obs.x + obs.w < 0) { obstacles.splice(i, 1); i--; }
        });

        enemies.forEach((enemy, i) => {
            if (enemy.update()) { // Returns true on hit
                enemies.splice(i, 1); i--;
            } else {
                enemy.draw();
                if (enemy.x < -50) { enemies.splice(i, 1); i--; }
            }
        });

        coins.forEach((coin, i) => {
            if (!coin.collected) {
                // –ú–∞–≥–Ω–∏—Ç
                let dist = Math.hypot(player.x - coin.x, player.y - coin.y);
                let magnetRange = 50 + (gameState.upgrades.magnetLvl * 30);
                if (dist < magnetRange) {
                    let angle = Math.atan2(player.y - coin.y, player.x - coin.x);
                    coin.vx += Math.cos(angle) * 1;
                    coin.vy += Math.sin(angle) * 1;
                    coin.x += coin.vx; coin.y += coin.vy;
                } else {
                    coin.x -= gameSpeed;
                }

                ctx.fillStyle = '#ff0'; ctx.shadowBlur = 15; ctx.shadowColor = '#ff0';
                ctx.beginPath(); ctx.arc(coin.x, coin.y, coin.radius, 0, Math.PI*2); ctx.fill(); ctx.shadowBlur = 0;

                // –°–±–æ—Ä (—É—á–∏—Ç—ã–≤–∞–µ–º —Ä–∞–¥–∏—É—Å –º–∞–≥–Ω–∏—Ç–∞ –¥–ª—è –ª–µ–≥–∫–æ–≥–æ —Å–±–æ—Ä–∞ –≤–±–ª–∏–∑–∏)
                if (dist < player.radius + coin.radius + 10) {
                    coin.collected = true;
                    // –§–æ—Ä–º—É–ª–∞ –æ—á–∫–æ–≤ —Å –º–Ω–æ–∂–∏—Ç–µ–ª–µ–º
                    let points = 10 * gameState.upgrades.multiplierLvl;
                    score += points;
                    coinsCollectedInRun++;
                    document.getElementById('scoreVal').innerText = score;
                    document.getElementById('coinsRunVal').innerText = coinsCollectedInRun;
                    for(let j=0; j<10; j++) particles.push(new Particle(coin.x, coin.y, '#ff0', 5));
                }
            }
            if (coin.x < 0 && !coin.collected) { coins.splice(i, 1); i--; }
        });

        player.update();
        if (!isGameOver) player.draw();

        if (!isGameOver) animationId = requestAnimationFrame(animate);
    }

    function handleBackground() {
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.1)'; ctx.lineWidth = 1;
        let offset = (frames * gameSpeed) % 80;
        for (let y = 0; y < canvas.height; y += 80) {
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
        }
        for (let x = 0 - offset; x < canvas.width; x += 80) {
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
        }
    }

    // --- –£–ü–†–ê–í–õ–ï–ù–ò–ï –°–û–°–¢–û–Ø–ù–ò–Ø–ú–ò ---
    function gameOver() {
        isGameOver = true;
        isGameRunning = false;
        // –°–æ—Ö—Ä–∞–Ω—è–µ–º –º–æ–Ω–µ—Ç—ã
        gameState.totalCoins += coinsCollectedInRun;
        saveData();

        document.getElementById('ui').style.display = 'none';
        document.getElementById('gameOverScreen').style.display = 'block';
        document.getElementById('finalScore').innerText = score;
        document.getElementById('finalCoins').innerText = coinsCollectedInRun;
    }

    function openShop() {
        document.getElementById('gameOverScreen').style.display = 'none';
        document.getElementById('shopScreen').style.display = 'block';
        updateShopUI();
    }

    function startGame() {
        // –°–±—Ä–æ—Å
        player.y = canvas.height / 2; player.dy = 0;
        obstacles = []; coins = []; particles = []; enemies = [];
        score = 0; coinsCollectedInRun = 0; frames = 0; gameSpeed = 3;
        isGameOver = false; isGameRunning = true;

        // UI
        document.getElementById('shopScreen').style.display = 'none';
        document.getElementById('ui').style.display = 'block';
        document.getElementById('scoreVal').innerText = '0';
        document.getElementById('coinsRunVal').innerText = '0';
        document.getElementById('shieldIndicator').style.display = gameState.upgrades.hasShield ? 'inline-block' : 'none';

        cancelAnimationFrame(animationId);
        animate();
    }

    // --- –§–£–ù–ö–¶–ò–ò –ú–ê–ì–ê–ó–ò–ù–ê ---
    function buyUpgrade(type) {
        let cost = getCost(type);
        if (gameState.totalCoins >= cost) {
            gameState.totalCoins -= cost;
            gameState.upgrades[type + 'Lvl']++;
            saveData();
        }
    }

    function buyShield() {
        if (!gameState.upgrades.hasShield && gameState.totalCoins >= shieldCost) {
            gameState.totalCoins -= shieldCost;
            gameState.upgrades.hasShield = true;
            saveData();
        }
    }

    function updateShopUI() {
        document.getElementById('totalCoinsVal').innerText = gameState.totalCoins;
        // –ú–∞–≥–Ω–∏—Ç
        document.getElementById('magnetLvl').innerText = gameState.upgrades.magnetLvl;
        document.getElementById('magnetCost').innerText = getCost('magnet');
        document.getElementById('buyMagnetBtn').disabled = gameState.totalCoins < getCost('magnet');
        // –ú–Ω–æ–∂–∏—Ç–µ–ª—å
        document.getElementById('multiplierLvl').innerText = gameState.upgrades.multiplierLvl;
        document.getElementById('multiplierCost').innerText = getCost('multiplier');
        document.getElementById('buyMultiplierBtn').disabled = gameState.totalCoins < getCost('multiplier');
        // –©–∏—Ç
        let shieldBtn = document.getElementById('buyShieldBtn');
        if (gameState.upgrades.hasShield) {
            shieldBtn.innerText = '–ö–£–ü–õ–ï–ù–û'; shieldBtn.disabled = true;
        } else {
            shieldBtn.innerText = '–ö–£–ü–ò–¢–¨';
            shieldBtn.disabled = gameState.totalCoins < shieldCost;
        }
    }

    // --- –ó–ê–ü–£–°–ö ---
    window.addEventListener('resize', () => {
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
    });
    // –ü—Ä–∏ –ø–µ—Ä–≤–æ–π –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ä–∞–∑—É –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞–≥–∞–∑–∏–Ω
    openShop();

</script>
</body>
</html>